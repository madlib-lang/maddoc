import List from "List"
import J from "Json"
import { Just, Nothing } from "Maybe"
import { always, any, equals, ifElse } from "Function"
import { drop, split, toLower, match, len } from "String"
import { isRootPathOf, canonicalizePath, FilePath } from "FilePath/Posix"
import {} from "Compare"

import {
  State
} from "./State"
import { Expression } from "./Views/Expression"
import {
  Module,
  Expression,
  Alias,
  Interface,
  Instance,
  Type
} from "./Parser/Documentation"



export type PathResult
  = ModuleResult (List Module)
  | ExpressionResult String Expression
  | TypeResult String Type
  | AliasResult String Alias
  | InterfaceResult String Interface
  | InstanceResult String Instance
  | NotFound


filterByPath :: String -> List Module -> List Module
filterByPath = (path) => {
  canPath = canonicalizePath(path)

  return List.filter((module) =>
    pipe(
      .name,
      toLower,
      ifElse(
        isRootPathOf(drop(1, toLower(canPath))),
        always(
          !List.isEmpty(module.expressions)
          || !List.isEmpty(module.typeDeclarations)
        ),
        pipe(
          always([
            ...map(.name, module.expressions),
            ...map(.name, module.typeDeclarations),
            ...map(.name, module.aliases),
            ...map(.name, module.interfaces),
            ...map(.declaration, module.instances)
          ]),
          map(pipe(mappend(`${module.name}/`), toLower)),
          any(isRootPathOf(drop(1, toLower(canPath))))
        )
      )
    )(module)
  )
}


getModulesToShow :: State -> List Module
export getModulesToShow = (state) => pipe(
  filterByPath(state.path),
  map((module) => ({
    ...module,
    expressions: List.filter(pipe(.name, match(state.search)), module.expressions)
  }))
)(state.modules)

isItemView :: String -> List Module -> Boolean
isItemView = (path) => ifElse(
  pipe(List.len, equals(1)),
  pipe(
    List.first,
    where
      is Just m : len(canonicalizePath(path)) > len(`/${m.name}`)
      is Nothing: false
  ),
  always(false)
)


findExpression :: FilePath -> Module -> PathResult
findExpression = (path, module) => pipe(
  .expressions,
  List.find((e) => Just(e.name) == List.last(split("/", path))),
  where
    is Just found: ExpressionResult(module.name, found)
    is Nothing   : NotFound
)(module)

findType :: FilePath -> Module -> PathResult
findType = (path, module) => pipe(
  .typeDeclarations,
  List.find((e) => Just(e.name) == List.last(split("/", path))),
  where
    is Just found: TypeResult(module.name, found)
    is Nothing   : NotFound
)(module)

findAlias :: FilePath -> Module -> PathResult
findAlias = (path, module) => pipe(
  .aliases,
  List.find((e) => Just(e.name) == List.last(split("/", path))),
  where
    is Just found: AliasResult(module.name, found)
    is Nothing   : NotFound
)(module)

findInterface :: FilePath -> Module -> PathResult
findInterface = (path, module) => pipe(
  .interfaces,
  List.find((e) => Just(e.name) == List.last(split("/", path))),
  where
    is Just found: InterfaceResult(module.name, found)
    is Nothing   : NotFound
)(module)

findInstance :: FilePath -> Module -> PathResult
findInstance = (path, module) => pipe(
  .instances,
  List.find((e) => Just(e.declaration) == List.last(split("/", path))),
  where
    is Just found: InstanceResult(module.name, found)
    is Nothing   : NotFound
)(module)


alias Finder = FilePath -> Module -> PathResult

_findItem :: List Finder -> FilePath -> Module -> PathResult
_findItem = (finders, path, module) => where(finders) {
  is [try, ...others]:
    where(try(path, module)) {
      is NotFound: _findItem(others, path, module)
      is found   : found
    }

  is []: NotFound
}

findItem :: FilePath -> Module -> PathResult
findItem = _findItem([
  findInstance,
  findExpression,
  findType,
  findAlias,
  findInterface
])


processPath :: State -> PathResult
export processPath = (state) => pipe(
  getModulesToShow,
  ifElse(
    isItemView(state.path),
    pipe(
      List.first,
      where is Just m: findItem(state.path, m)
    ),
    ModuleResult
  )
)(state)
