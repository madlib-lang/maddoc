{
  "modules": [
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Monad.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "Monad",
          "vars": "m",
          "constraints": "Applicative m",
          "description": "",
          "example": "",
          "since": "",
          "methods": [
            "chain :: (a -> m b) -> m a -> m b",
            "of :: a -> m a"
          ]
        }
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "andDo",
          "description": "",
          "example": "",
          "since": "",
          "type": "m a -> m b -> m a"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Maybe.mad",
      "description": "Maybe is one of the major data types in functional programming and serves to\nrepresent things that have the possibility of not existing or potentially failing.\nAny computation that could fail or return anything like \"null, nil, undefined, ..\" in\nother procedural/OO languages would benefit from relying on Maybe instead.",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "Maybe is a type that serve to represent values that can potentially\nnot exist. It's used for things like List.nth or List.last. When the\nitem you're looking for is not in the list a Nothing is returned instead\nof \"Just\" the item.",
          "example": "Just(3)     // Just(3) :: Maybe Number\nJust(false) // Just(false) :: Maybe Boolean\nNothing     // Nothing :: Maybe a",
          "since": "0.0.5",
          "name": "Maybe",
          "params": "a",
          "constructors": [
            "Just a",
            "Nothing "
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Functor",
          "description": "The Functor instance of Maybe maps over the value only if a value exists,\nunderstand it is a Just. Otherwise it returns Nothing.",
          "example": "map((x) => x + 1, Just(0)) // Just(1)\nmap((x) => x + 1, Nothing) // Nothing",
          "since": "0.0.6",
          "constraints": "",
          "declaration": "Functor Maybe"
        },
        {
          "name": "Applicative",
          "description": "The Applicative instance of Maybe defines ap that applies a function wrapped in\na Maybe to a value wrapped in a Maybe. If one of the two is a Nothing, it\nreturns Nothing.",
          "example": "ap(Just((x) => x + 1), Just(0)) // Just(1)\nap(Just((x) => x + 1), Nothing) // Nothing\nap(Nothing, Just(3))            // Nothing",
          "since": "0.0.6",
          "constraints": "",
          "declaration": "Applicative Maybe"
        },
        {
          "name": "Monad",
          "description": "The Monad instance of Maybe defines chain that applies a function that returns a\nMaybe to a value wrapped in a Maybe.",
          "example": "chain((x) => Just(x + 1), Just(1)) // Just(2)",
          "since": "0.0.6",
          "constraints": "",
          "declaration": "Monad Maybe"
        },
        {
          "name": "Show",
          "description": "The Show instance of Maybe returns Just or Nothing, following by the showed\nvalue it contains.",
          "example": "show(Just(3))                   // \"Just 3\"\nshow((Nothing :: Maybe Number)) // \"Nothing\"",
          "since": "0.0.6",
          "constraints": "Show a",
          "declaration": "Show (Maybe a)"
        }
      ],
      "expressions": [
        {
          "name": "fromMaybe",
          "description": "fromMaybe returns the value contained in the Maybe if it is a Just, or the\nfallback value otherwise.",
          "example": "fromMaybe(3, Just(4)) // 4\nfromMaybe(3, Nothing) // 3",
          "since": "0.0.5",
          "type": "a -> Maybe a -> a"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/MonadWriter.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "MonadWriter",
          "vars": "w m",
          "constraints": "(Monoid w, Monad m)",
          "description": "",
          "example": "",
          "since": "",
          "methods": [
            "tell :: w -> m ()"
          ]
        }
      ],
      "instances": [
        {
          "name": "MonadWriter",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "(Monoid w, Monad m)",
          "declaration": "MonadWriter w (WriterT w m)"
        },
        {
          "name": "MonadWriter",
          "description": "instance MonadWriter for StateT",
          "example": "",
          "since": "",
          "constraints": "(Monoid w, Monad m, MonadWriter w m)",
          "declaration": "MonadWriter w (StateT s m)"
        }
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Maybe.spec.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Applicative.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "Applicative",
          "vars": "m",
          "constraints": "Functor m",
          "description": "",
          "example": "",
          "since": "",
          "methods": [
            "ap :: m (a -> b) -> m a -> m b",
            "pure :: a -> m a"
          ]
        }
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/LcovDotInfo.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "LcovLine type",
          "example": "",
          "since": "v0.0.5",
          "name": "LcovLine",
          "params": "",
          "constructors": [
            "TN String",
            "SF String",
            "FN Number String",
            "FNDA Number String",
            "FNF Number",
            "FNH Number",
            "DA Number Number",
            "LF Number",
            "LH Number"
          ]
        }
      ],
      "aliases": [
        {
          "type": "Alias",
          "description": "LcovLine type",
          "example": "",
          "since": "v0.0.5",
          "name": "LcovSection",
          "params": "",
          "aliasedType": "{ das :: List LcovLine, fndas :: List LcovLine, fnf :: LcovLine, fnh :: LcovLine, fns :: List LcovLine, lf :: LcovLine, lh :: LcovLine, sf :: LcovLine, tn :: LcovLine }"
        },
        {
          "type": "Alias",
          "description": "",
          "example": "",
          "since": "",
          "name": "LcovInfo",
          "params": "",
          "aliasedType": "(List LcovSection)"
        }
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "getPath",
          "description": "",
          "example": "",
          "since": "",
          "type": "{ das :: List LcovLine, fndas :: List LcovLine, fnf :: LcovLine, fnh :: LcovLine, fns :: List LcovLine, lf :: LcovLine, lh :: LcovLine, sf :: LcovLine, tn :: LcovLine } -> String"
        },
        {
          "name": "parseLcov",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> List { das :: List LcovLine, fndas :: List LcovLine, fnf :: LcovLine, fnh :: LcovLine, fns :: List LcovLine, lf :: LcovLine, lh :: LcovLine, sf :: LcovLine, tn :: LcovLine }"
        },
        {
          "name": "stringify",
          "description": "",
          "example": "",
          "since": "",
          "type": "List { das :: List LcovLine, fndas :: List LcovLine, fnf :: LcovLine, fnh :: LcovLine, fns :: List LcovLine, lf :: LcovLine, lh :: LcovLine, sf :: LcovLine, tn :: LcovLine } -> String"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/String.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Semigroup",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Semigroup String"
        },
        {
          "name": "Monoid",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Monoid String"
        },
        {
          "name": "Show",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Show String"
        }
      ],
      "expressions": [
        {
          "name": "replace",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> String -> String -> String"
        },
        {
          "name": "split",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> String -> List String"
        },
        {
          "name": "lines",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> List String"
        },
        {
          "name": "mapChars",
          "description": "",
          "example": "",
          "since": "",
          "type": "(String -> String) -> String -> String"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Binary.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "ByteWord",
          "params": "",
          "constructors": [
            "Int8Bit a",
            "Int16Bit a",
            "Int32Bit a"
          ]
        },
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "ByteArray",
          "params": "",
          "constructors": [
            "ByteArray (List ByteWord)"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Identity.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "Identity",
          "params": "a",
          "constructors": [
            "Identity a"
          ]
        },
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "IdentityT",
          "params": "m a",
          "constructors": [
            "IdentityT (m a)"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Functor",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Functor Identity"
        },
        {
          "name": "Applicative",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Applicative Identity"
        },
        {
          "name": "Monad",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Monad Identity"
        },
        {
          "name": "Functor",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Functor m",
          "declaration": "Functor (IdentityT m)"
        },
        {
          "name": "Applicative",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Applicative m",
          "declaration": "Applicative (IdentityT m)"
        },
        {
          "name": "Monad",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Monad m",
          "declaration": "Monad (IdentityT m)"
        },
        {
          "name": "MonadTrans",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Monad m",
          "declaration": "MonadTrans m IdentityT"
        }
      ],
      "expressions": [
        {
          "name": "runIdentity",
          "description": "",
          "example": "",
          "since": "",
          "type": "Identity a -> a"
        },
        {
          "name": "runIdentityT",
          "description": "",
          "example": "",
          "since": "",
          "type": "IdentityT m a -> m a"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Either.spec.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Math.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "add",
          "description": "",
          "example": "",
          "since": "",
          "type": "Number -> Number -> Number"
        },
        {
          "name": "substract",
          "description": "",
          "example": "",
          "since": "",
          "type": "Number -> Number -> Number"
        },
        {
          "name": "multiply",
          "description": "",
          "example": "",
          "since": "",
          "type": "Number -> Number -> Number"
        },
        {
          "name": "divide",
          "description": "",
          "example": "",
          "since": "",
          "type": "Number -> Number -> Number"
        },
        {
          "name": "mod",
          "description": "",
          "example": "",
          "since": "",
          "type": "Number -> Number -> Number"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/TestTools.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "collectCoverage",
          "description": "",
          "example": "",
          "since": "",
          "type": "List HitPoint -> Wish a (List { cols :: List <String, String>, id :: String })"
        },
        {
          "name": "test",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> (String -> Wish AssertionError String) -> ()"
        },
        {
          "name": "assertEquals",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> a -> Wish AssertionError String"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/String.spec.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Semigroup.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "Semigroup",
          "vars": "a",
          "constraints": "",
          "description": "",
          "example": "",
          "since": "",
          "methods": [
            "assoc :: a -> a -> a"
          ]
        }
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/WriterT.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "WriterT",
          "params": "w m a",
          "constructors": [
            "WriterT (m <a, w>)"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Functor",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Functor m",
          "declaration": "Functor (WriterT w m)"
        },
        {
          "name": "Applicative",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "(Applicative m, Monoid w)",
          "declaration": "Applicative (WriterT w m)"
        },
        {
          "name": "Monad",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "(Monoid w, Monad m)",
          "declaration": "Monad (WriterT w m)"
        },
        {
          "name": "MonadTrans",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "(Monad m, Monoid w)",
          "declaration": "MonadTrans m (WriterT w)"
        }
      ],
      "expressions": [
        {
          "name": "runWriterT",
          "description": "",
          "example": "",
          "since": "",
          "type": "WriterT a m b -> m <b, a>"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Tuple.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Show",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "(Show a, Show b)",
          "declaration": "Show (<a, b>)"
        },
        {
          "name": "Show",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "(Show a, Show b, Show c)",
          "declaration": "Show (<a, b, c>)"
        },
        {
          "name": "Show",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "(Show a, Show b, Show c, Show d)",
          "declaration": "Show (<a, b, c, d>)"
        }
      ],
      "expressions": [
        {
          "name": "fst",
          "description": "",
          "example": "",
          "since": "",
          "type": "<a, b> -> a"
        },
        {
          "name": "snd",
          "description": "",
          "example": "",
          "since": "",
          "type": "<a, b> -> b"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/System.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "CommandError",
          "params": "",
          "constructors": [
            "CommandError Number String"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "exec",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Wish CommandError String"
        },
        {
          "name": "spawn",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Wish CommandError Number"
        },
        {
          "name": "getArgs",
          "description": "",
          "example": "",
          "since": "",
          "type": "Wish String (List String)"
        },
        {
          "name": "getEnv",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Wish String String"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/List.mad",
      "description": "List utility functions.\nIn this module you'll find everything that is related to List and make working with lists convenient.",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Functor",
          "description": "Functor instance for List",
          "example": "map((x) => x * 2, [1, 2, 3]) // [2, 4, 6]",
          "since": "v0.0.6",
          "constraints": "",
          "declaration": "Functor List"
        },
        {
          "name": "Applicative",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Applicative List"
        },
        {
          "name": "Monad",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Monad List"
        },
        {
          "name": "Semigroup",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Semigroup (List a)"
        },
        {
          "name": "Monoid",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Monoid (List a)"
        },
        {
          "name": "Show",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Show a",
          "declaration": "Show (List a)"
        }
      ],
      "expressions": [
        {
          "name": "singleton",
          "description": "Constructor function that creates a list with length 1. It takes an item of any type, and returns a List of that type.",
          "example": "singleton(1)   // [1]\nsingleton(\"1\") // [\"1\"]",
          "since": "0.0.5",
          "type": "a -> List a"
        },
        {
          "name": "unlines",
          "description": "Flattens a List String into a String, by adding line returns between the items in the List.",
          "example": "unlines([\"line1\", \"line2\", \"line3\"]) // \"line1\\nline2\\nline3\"",
          "since": "0.0.5",
          "type": "List String -> String"
        },
        {
          "name": "intercalate",
          "description": "Intercalates a value between all elements of a list.",
          "example": "intercalate(\"and\", [\"cats\", \"dogs\"]) // [\"cats\", \"and\", \"dogs\"]",
          "since": "0.0.5",
          "type": "a -> List a -> List a"
        },
        {
          "name": "join",
          "description": "Joins a list with a separator and returns a String.\n\nIMPORTANT:\nWhen coming from JS, beware that there is a small difference with Array.prototype.join.\nIn JS, join relies on its dynamic nature and accepts any type as being valid, and transforms it\nto a string for you. In Madlib you need to provide an instance of Show for your custom types, and\nfor Madlib types (eg. tuples, List, Boolean, Maybe) it uses the Show instance defined for them.",
          "example": "join(\" and \", [\"cats\", \"dogs\"])   // \"cats and dogs\"\njoin(\"\", [\"one\", \"two\", \"three\"]) // \"onetwothree\"",
          "since": "0.0.5",
          "type": "a -> List b -> String"
        },
        {
          "name": "mapWithIndex",
          "description": "Applies a function to each item of a list. This function receives the current element\nas well as its index as parameters, and must return the transformed item.",
          "example": "mapWithIndex((x, i) => x ++ show(i), [\"a\", \"b\", \"c\"]) // [\"a0\", \"b1\", \"c2\"]",
          "since": "0.0.5",
          "type": "(a -> Number -> b) -> List a -> List b"
        },
        {
          "name": "concat",
          "description": "Concatenates two lists together.",
          "example": "concat([1, 2, 3], [4, 5, 6]) // [1, 2, 3, 4, 5, 6]",
          "since": "0.0.5",
          "type": "List a -> List a -> List a"
        },
        {
          "name": "append",
          "description": "Appends an item to a list. The item is then pushed at the end of it.",
          "example": "append(2, [1]) // [1, 2]",
          "since": "0.0.5",
          "type": "a -> List a -> List a"
        },
        {
          "name": "last",
          "description": "Returns a Maybe containing either a Just with the last element or a Nothing if the list is empty.",
          "example": "last([1, 2, 3]) // Just(3)\nlast([])        // Nothing",
          "since": "0.0.5",
          "type": "List a -> Maybe a"
        },
        {
          "name": "first",
          "description": "Returns a Maybe containing either a Just with the first element or a Nothing if the list is empty.",
          "example": "first([1, 2, 3]) // Just(1)\nfirst([])        // Nothing",
          "since": "0.0.5",
          "type": "List a -> Maybe a"
        },
        {
          "name": "init",
          "description": "Returns the list without the last item.",
          "example": "init([1, 2, 3]) // [1, 2]\ninit([])        // []",
          "since": "0.0.5",
          "type": "List a -> List a"
        },
        {
          "name": "nth",
          "description": "Returns a Just of the nth element in a list if an element exists at that index or a Nothing otherwise.",
          "example": "nth(1, [1, 2, 3]) // Just(2)\nnth(3, [1, 2, 3]) // Nothing",
          "since": "0.0.5",
          "type": "Number -> List a -> Maybe a"
        },
        {
          "name": "reduceR",
          "description": "",
          "example": "",
          "since": "0.0.5",
          "type": "(a -> b -> a) -> a -> List b -> a"
        },
        {
          "name": "reduceL",
          "description": "",
          "example": "",
          "since": "0.0.5",
          "type": "(a -> b -> a) -> a -> List b -> a"
        },
        {
          "name": "reduce",
          "description": "Returns a transformed value derived from all elements of a list.\nTo do this reduce takes three parameters:\n- a transformation function, that receives the currently transformed output ( an accumulator ) and the current item of the list\n- an initial value that must have the same type as the value returned from the transformation function\n- a list",
          "example": "reduce((a, b) => a + b, 0, [1, 2, 3]) // 6",
          "since": "0.0.5",
          "type": "(a -> b -> a) -> a -> List b -> a"
        },
        {
          "name": "filter",
          "description": "Filters a list given a predicate function that is called with each element of the list and must return a Boolean.",
          "example": "filter((a) => a % 2 == 0, [1, 2, 3, 4, 5, 6]) // [2, 4, 6]",
          "since": "0.0.5",
          "type": "(a -> Boolean) -> List a -> List a"
        },
        {
          "name": "reject",
          "description": "Removes items from a list for which the given predicate function returns true. In\nother words it is the complement of filter.",
          "example": "reject((a) => a % 2 == 0, [1, 2, 3, 4, 5, 6]) // [1, 3, 5]",
          "since": "0.0.5",
          "type": "(a -> Boolean) -> List a -> List a"
        },
        {
          "name": "find",
          "description": "Returns a Just of the first element for which the given predicate function returns true, or Nothing otherwise.",
          "example": "find((a) => a % 2 == 0, [1, 2, 3, 4, 5, 6]) // Just(2)\nfind((a) => a == 0, [1, 2, 3, 4, 5, 6])     // Nothing",
          "since": "0.0.5",
          "type": "(a -> Boolean) -> List a -> Maybe a"
        },
        {
          "name": "len",
          "description": "Returns the length of a list",
          "example": "len([1, 2, 3]) // 3",
          "since": "0.0.5",
          "type": "List a -> Number"
        },
        {
          "name": "slice",
          "description": "",
          "example": "",
          "since": "0.0.5",
          "type": "Number -> Number -> List a -> List a"
        },
        {
          "name": "isEmpty",
          "description": "",
          "example": "",
          "since": "0.0.5",
          "type": "List a -> Boolean"
        },
        {
          "name": "uniqueBy",
          "description": "Makes items of a list unique given an equality functions that serves to decide\nhow items should be dedupped.\nNB: It keeps the last item that matches the binary predicate.",
          "example": "uniqueBy(\n(a, b) => a.id == b.id,\n[\n{ id: 1, name: \"John\" },\n{ id: 2, name: \"Paul\" },\n{ id: 1, name: \"George\" },\n{ id: 4, name: \"Ringo\" }\n]\n)\n// [{ id: 2, name: \"Paul\" }, { id: 1, name: \"George\" }, { id: 4, name: \"Ringo\" }]",
          "since": "0.0.5",
          "type": "(a -> a -> Boolean) -> List a -> List a"
        },
        {
          "name": "flatten",
          "description": "",
          "example": "",
          "since": "0.0.5",
          "type": "List (List a) -> List a"
        },
        {
          "name": "zip",
          "description": "",
          "example": "",
          "since": "0.0.5",
          "type": "List a -> List b -> List <a, b>"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Either.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "Either is a type that carries values that may fail. An Either can be a Right\nof a successful computation, or a Left that contains an error.",
          "example": "",
          "since": "0.0.5",
          "name": "Either",
          "params": "e a",
          "constructors": [
            "Left e",
            "Right a"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Functor",
          "description": "The Functor instance of Either allows for a function which conditionally\ntransforms a value (if it is a Right) or leaves it unchanged if it is a Left.",
          "example": "map((x) => x + 1, Right(3))      // Right(4)\nmap((x) => x + 1, Left(\"error\")) // Left(\"error\")",
          "since": "0.0.6",
          "constraints": "",
          "declaration": "Functor (Either e)"
        },
        {
          "name": "Applicative",
          "description": "The Applicative instance of Either defines ap that applies a function wrapped\nin an Either over the value of an other Either. If both parameters are Rights,\nit returns a Right of the result. If the first parameter is a Left it returns\nthat error, regardless of what is contained in the second parameter. If the\nfirst parameter is a Right and the second one a Left, returns a Left carrying\nthat error value.",
          "example": "ap(Right((x) => x + 1), Right(2))     // Right(3)\nap(Left(\"oups\"), Right(2))            // Left(\"oups\")\nap(Right((x) => x + 1), Left(\"oups\")) // Left(\"oups\")",
          "since": "0.0.6",
          "constraints": "",
          "declaration": "Applicative (Either e)"
        },
        {
          "name": "Monad",
          "description": "The Monad instance of Either defines chain.",
          "example": "chain((x) => Right(x + 1), Right(1))   // Right(2)\nchain((x) => Right(x + 1), Left(\"no\")) // Left(\"no\")",
          "since": "0.0.6",
          "constraints": "",
          "declaration": "Monad (Either e)"
        },
        {
          "name": "Show",
          "description": "The Show instance of Maybe returns Right or Left, following by the showed\nvalue it contains.",
          "example": "show((Right(3) :: Either Number Number)) // \"Right 3\"\nshow((Left(3) :: Either Number Number))  // \"Left 3\"",
          "since": "0.0.6",
          "constraints": "(Show e, Show a)",
          "declaration": "Show (Either e a)"
        }
      ],
      "expressions": [
        {
          "name": "mapRight",
          "description": "Alias for map, it applies a function to the contained value if it is a Right.",
          "example": "mapRight((x) => x + 1, Right(3)) // Right(4)",
          "since": "0.0.5",
          "type": "(a -> b) -> Either c a -> Either c b"
        },
        {
          "name": "mapLeft",
          "description": "Applies a function to the contained value if it is a Left.",
          "example": "mapLeft((x) => x + 1, Left(3))  // Left(4)\nmapLeft((x) => x + 1, Right(3)) // Right(3)",
          "since": "0.0.5",
          "type": "(a -> b) -> Either a c -> Either b c"
        },
        {
          "name": "isLeft",
          "description": "Returns true if it is a Left, false otherwise.",
          "example": "isLeft(Left(1))  // true\nisLeft(Right(1)) // false",
          "since": "0.0.5",
          "type": "Either a b -> Boolean"
        },
        {
          "name": "isRight",
          "description": "Returns true if it is a Right, false otherwise.",
          "example": "isRight(Left(1))  // false\nisRight(Right(1)) // true",
          "since": "0.0.5",
          "type": "Either a b -> Boolean"
        },
        {
          "name": "fromRight",
          "description": "Returns the value contained in the Either if it is a Right, or the given\nfallback value otherwise.",
          "example": "fromRight(1, Right(4)) // 4\nfromRight(1, Left(4))  // 1",
          "since": "0.0.5",
          "type": "a -> Either b a -> a"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Http.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "Body",
          "params": "",
          "constructors": [
            "TextBody String",
            "BinaryBody B.ByteArray"
          ]
        },
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "Response",
          "params": "",
          "constructors": [
            "Response { body :: Body }"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "get",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Wish a Response"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/List.spec.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Function.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "complement",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> Boolean) -> a -> Boolean"
        },
        {
          "name": "always",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> b -> a"
        },
        {
          "name": "identity",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> a"
        },
        {
          "name": "equals",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> a -> Boolean"
        },
        {
          "name": "ifElse",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b"
        },
        {
          "name": "when",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> Boolean) -> (a -> a) -> a -> a"
        },
        {
          "name": "not",
          "description": "",
          "example": "",
          "since": "",
          "type": "Boolean -> Boolean"
        },
        {
          "name": "flip",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b -> c) -> b -> a -> c"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/FileSystem.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "Data",
          "params": "",
          "constructors": [
            "TextData String",
            "BinaryData B.ByteArray"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "writeFile",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Data -> Wish a String"
        },
        {
          "name": "readFile",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Wish a String"
        },
        {
          "name": "exists",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Wish a String"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/IO.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        {
          "type": "Alias",
          "description": "",
          "example": "",
          "since": "",
          "name": "Row",
          "params": "",
          "aliasedType": "{ cols :: List <String, String>, id :: String }"
        }
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "log",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> a"
        },
        {
          "name": "trace",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> a -> a"
        },
        {
          "name": "err",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> a"
        },
        {
          "name": "warn",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> a"
        },
        {
          "name": "inspect",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> a"
        },
        {
          "name": "table",
          "description": "",
          "example": "",
          "since": "",
          "type": "List { cols :: List <String, String>, id :: String } -> a -> a"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Show.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "Show",
          "vars": "a",
          "constraints": "",
          "description": "DESC",
          "example": "",
          "since": "v0.0.6",
          "methods": [
            "show :: a -> String"
          ]
        }
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Json.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        {
          "type": "Alias",
          "description": "",
          "example": "",
          "since": "",
          "name": "Parser",
          "params": "r",
          "aliasedType": "(String -> Either String r)"
        }
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "string",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Either String String"
        },
        {
          "name": "number",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Either String Number"
        },
        {
          "name": "boolean",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Either String Boolean"
        },
        {
          "name": "dict",
          "description": "",
          "example": "",
          "since": "",
          "type": "(String -> Either String a) -> String -> Either String (Dictionary String a)"
        },
        {
          "name": "list",
          "description": "",
          "example": "",
          "since": "",
          "type": "(String -> Either String a) -> String -> Either String (List a)"
        },
        {
          "name": "map1",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b) -> (String -> Either String a) -> String -> Either String b"
        },
        {
          "name": "map2",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b -> c) -> (String -> Either String a) -> (String -> Either String b) -> String -> Either String c"
        },
        {
          "name": "map3",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b -> c -> d) -> (String -> Either String a) -> (String -> Either String b) -> (String -> Either String c) -> String -> Either String d"
        },
        {
          "name": "map4",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b -> c -> d -> e) -> (String -> Either String a) -> (String -> Either String b) -> (String -> Either String c) -> (String -> Either String d) -> String -> Either String e"
        },
        {
          "name": "map5",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b -> c -> d -> e -> f) -> (String -> Either String a) -> (String -> Either String b) -> (String -> Either String c) -> (String -> Either String d) -> (String -> Either String e) -> String -> Either String f"
        },
        {
          "name": "map6",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b -> c -> d -> e -> f -> g) -> (String -> Either String a) -> (String -> Either String b) -> (String -> Either String c) -> (String -> Either String d) -> (String -> Either String e) -> (String -> Either String f) -> String -> Either String g"
        },
        {
          "name": "map7",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b -> c -> d -> e -> f -> g -> h) -> (String -> Either String a) -> (String -> Either String b) -> (String -> Either String c) -> (String -> Either String d) -> (String -> Either String e) -> (String -> Either String f) -> (String -> Either String g) -> String -> Either String h"
        },
        {
          "name": "maybe",
          "description": "",
          "example": "",
          "since": "",
          "type": "(String -> Either String a) -> String -> Either String (Maybe a)"
        },
        {
          "name": "lazy",
          "description": "",
          "example": "",
          "since": "",
          "type": "(() -> String -> Either String a) -> String -> Either String a"
        },
        {
          "name": "field",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> (String -> Either String a) -> String -> Either String a"
        },
        {
          "name": "parse",
          "description": "",
          "example": "",
          "since": "",
          "type": "(String -> Either String a) -> String -> Either String a"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/HitPoint.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "HitPoint",
          "params": "",
          "constructors": [
            "FunctionHit String String",
            "LineHit String Number"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        
      ],
      "expressions": [
        {
          "name": "getHitPoints",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> List HitPoint"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/MonadTrans.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "MonadTrans",
          "vars": "m t",
          "constraints": "Monad m",
          "description": "",
          "example": "",
          "since": "",
          "methods": [
            "lift :: m a -> t m a"
          ]
        }
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Monoid.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "Monoid",
          "vars": "w",
          "constraints": "Semigroup w",
          "description": "",
          "example": "",
          "since": "",
          "methods": [
            "mappend :: w -> w -> w",
            "mempty :: w"
          ]
        }
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Number.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Show",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Show Number"
        }
      ],
      "expressions": [
        {
          "name": "fromString",
          "description": "",
          "example": "",
          "since": "",
          "type": "String -> Maybe Number"
        },
        {
          "name": "formatDecimal",
          "description": "",
          "example": "",
          "since": "",
          "type": "Number -> Number -> String"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Dictionary.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "Dictionary",
          "params": "k v",
          "constructors": [
            "Dictionary (List <k, v>)"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Functor",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Functor (Dictionary k)"
        }
      ],
      "expressions": [
        {
          "name": "fromList",
          "description": "",
          "example": "",
          "since": "",
          "type": "List <a, b> -> Dictionary a b"
        },
        {
          "name": "empty",
          "description": "",
          "example": "",
          "since": "",
          "type": "Dictionary a b"
        },
        {
          "name": "insert",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> b -> Dictionary a b -> Dictionary a b"
        },
        {
          "name": "get",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> Dictionary a b -> Maybe b"
        },
        {
          "name": "keys",
          "description": "",
          "example": "",
          "since": "",
          "type": "Dictionary a b -> List a"
        },
        {
          "name": "values",
          "description": "",
          "example": "",
          "since": "",
          "type": "Dictionary a b -> List b"
        },
        {
          "name": "len",
          "description": "",
          "example": "",
          "since": "",
          "type": "Dictionary a b -> Number"
        },
        {
          "name": "mapWithKey",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b -> c) -> Dictionary a b -> Dictionary a c"
        },
        {
          "name": "merge",
          "description": "",
          "example": "",
          "since": "",
          "type": "Dictionary a b -> Dictionary a b -> Dictionary a b"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/MonadState.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "MonadState",
          "vars": "s m",
          "constraints": "Monad m",
          "description": "",
          "example": "",
          "since": "",
          "methods": [
            "get :: m s",
            "modify :: (s -> s) -> m ()",
            "put :: s -> m ()"
          ]
        }
      ],
      "instances": [
        {
          "name": "MonadState",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Monad m",
          "declaration": "MonadState s (StateT s m)"
        },
        {
          "name": "MonadState",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "(Monoid w, Monad m, MonadState s m)",
          "declaration": "MonadState s (WriterT w m)"
        }
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/StateT.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "StateT",
          "params": "s m a",
          "constructors": [
            "StateT (s -> m <a, s>)"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Functor",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Functor m",
          "declaration": "Functor (StateT s m)"
        },
        {
          "name": "Applicative",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Monad m",
          "declaration": "Applicative (StateT s m)"
        },
        {
          "name": "Monad",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Monad m",
          "declaration": "Monad (StateT s m)"
        },
        {
          "name": "MonadTrans",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "Monad m",
          "declaration": "MonadTrans m (StateT s)"
        }
      ],
      "expressions": [
        {
          "name": "runStateT",
          "description": "",
          "example": "",
          "since": "",
          "type": "StateT a m b -> a -> m <b, a>"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Wish.mad",
      "description": "",
      "typeDeclarations": [
        {
          "type": "ADT",
          "description": "",
          "example": "",
          "since": "",
          "name": "Wish",
          "params": "e a",
          "constructors": [
            "Wish ((e -> f) -> (a -> b) -> ())"
          ]
        }
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Functor",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Functor (Wish e)"
        },
        {
          "name": "Applicative",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Applicative (Wish e)"
        },
        {
          "name": "Monad",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Monad (Wish e)"
        }
      ],
      "expressions": [
        {
          "name": "mapRej",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b) -> Wish a c -> Wish b c"
        },
        {
          "name": "chainRej",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> Wish b c) -> Wish a c -> Wish b c"
        },
        {
          "name": "good",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> Wish b a"
        },
        {
          "name": "bad",
          "description": "",
          "example": "",
          "since": "",
          "type": "a -> Wish a b"
        },
        {
          "name": "parallel",
          "description": "",
          "example": "",
          "since": "",
          "type": "List (Wish a b) -> Wish a (List b)"
        },
        {
          "name": "fulfill",
          "description": "",
          "example": "",
          "since": "",
          "type": "(a -> b) -> (c -> d) -> Wish a c -> ()"
        },
        {
          "name": "after",
          "description": "",
          "example": "",
          "since": "",
          "type": "Number -> a -> Wish b a"
        }
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Functor.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        {
          "name": "Functor",
          "vars": "m",
          "constraints": "",
          "description": "",
          "example": "",
          "since": "",
          "methods": [
            "map :: (a -> b) -> m a -> m b"
          ]
        }
      ],
      "instances": [
        
      ],
      "expressions": [
        
      ]
    },
    {
      "path": "/Users/a.boeglin/Code/madlib/prelude/__internal__/Boolean.mad",
      "description": "",
      "typeDeclarations": [
        
      ],
      "aliases": [
        
      ],
      "interfaces": [
        
      ],
      "instances": [
        {
          "name": "Show",
          "description": "",
          "example": "",
          "since": "",
          "constraints": "",
          "declaration": "Show Boolean"
        }
      ],
      "expressions": [
        
      ]
    }
  ]
}
